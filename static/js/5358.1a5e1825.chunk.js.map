{"version":3,"file":"static/js/5358.1a5e1825.chunk.js","mappings":"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","sources":["../node_modules/viem/errors/abi.ts","../node_modules/viem/errors/address.ts","../node_modules/viem/utils/abi/encodeAbiParameters.ts","../node_modules/viem/utils/abi/prepareEncodeFunctionData.ts","../node_modules/viem/utils/abi/encodeFunctionData.ts","../node_modules/viem/utils/abi/formatAbiItem.ts","../node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/viem/utils/address/getAddress.ts","../node_modules/viem/utils/address/isAddress.ts","../node_modules/viem/utils/data/concat.ts","../node_modules/viem/utils/data/slice.ts","../node_modules/viem/utils/encoding/toBytes.ts","../node_modules/viem/utils/hash/keccak256.ts","../node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/viem/utils/hash/toFunctionSelector.ts","../node_modules/viem/utils/hash/hashSignature.ts","../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../node_modules/viem/utils/hash/toSignature.ts","../node_modules/viem/utils/hash/normalizeSignature.ts","../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiItem.ts","../node_modules/viem/utils/hash/toSignatureHash.ts","../node_modules/viem/utils/regex.ts","../node_modules/viem/constants/strings.ts","../node_modules/viem/utils/signature/hashMessage.ts","../node_modules/viem/utils/signature/toPrefixedMessage.ts","../node_modules/viem/errors/typedData.ts","../node_modules/viem/utils/typedData.ts","../node_modules/viem/utils/signature/hashTypedData.ts","../node_modules/viem/node_modules/abitype/src/regex.ts"],"sourcesContent":["import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize, 10))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import type {\n  Abi,\n  AbiStateMutability,\n  ExtractAbiFunction,\n  ExtractAbiFunctions,\n} from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport type { ConcatHexErrorType } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionData'\n\nexport type PrepareEncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<{ args?: allArgs | undefined }> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type PrepareEncodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n> = {\n  abi: abi extends Abi\n    ? functionName extends ContractFunctionName<abi>\n      ? [ExtractAbiFunction<abi, functionName>]\n      : abi\n    : Abi\n  functionName: Hex\n}\n\nexport type PrepareEncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function prepareEncodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: PrepareEncodeFunctionDataParameters<abi, functionName>,\n): PrepareEncodeFunctionDataReturnType<abi, functionName> {\n  const { abi, args, functionName } =\n    parameters as PrepareEncodeFunctionDataParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem(abiItem)),\n  } as unknown as PrepareEncodeFunctionDataReturnType<abi, functionName>\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport type { AbiFunctionNotFoundErrorType } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport type { ToFunctionSelectorErrorType } from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport type { FormatAbiItemErrorType } from './formatAbiItem.js'\nimport type { GetAbiItemErrorType } from './getAbiItem.js'\nimport { prepareEncodeFunctionData } from './prepareEncodeFunctionData.js'\n\nexport type EncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | Hex\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<\n    readonly [] extends allArgs\n      ? { args?: allArgs | undefined }\n      : { args: allArgs }\n  > &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionDataReturnType = Hex\n\nexport type EncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | EncodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function encodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionDataParameters<abi, functionName>,\n): EncodeFunctionDataReturnType {\n  const { args } = parameters as EncodeFunctionDataParameters\n\n  const { abi, functionName } = (() => {\n    if (\n      parameters.abi.length === 1 &&\n      parameters.functionName?.startsWith('0x')\n    )\n      return parameters as { abi: Abi; functionName: Hex }\n    return prepareEncodeFunctionData(parameters)\n  })()\n\n  const abiItem = abi[0]\n  const signature = functionName\n\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, args ?? [])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import type { ErrorType } from '../../errors/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_, 10) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_, 10),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: {\n  domain?: TypedDataDomain | undefined\n}): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n"],"names":["AbiConstructorNotFoundError","BaseError","constructor","_ref","docsPath","super","join","name","AbiConstructorParamsNotFoundError","_ref2","AbiDecodingDataSizeTooSmallError","_ref4","data","params","size","concat","metaMessages","formatAbiParams","includeName","Object","defineProperty","this","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","_ref5","expectedLength","givenLength","type","AbiEncodingBytesSizeMismatchError","_ref6","expectedSize","value","AbiEncodingLengthMismatchError","_ref7","AbiErrorInputsNotFoundError","errorName","_ref8","AbiErrorNotFoundError","arguments","length","undefined","AbiErrorSignatureNotFoundError","signature","_ref9","AbiEventSignatureEmptyTopicsError","_ref10","AbiEventSignatureNotFoundError","_ref11","AbiEventNotFoundError","eventName","AbiFunctionNotFoundError","functionName","AbiFunctionOutputsNotFoundError","_ref12","AbiFunctionSignatureNotFoundError","_ref13","AbiItemAmbiguityError","x","y","formatAbiItem","abiItem","BytesSizeMismatchError","_ref14","givenSize","DecodeLogDataMismatch","_ref15","DecodeLogTopicsMismatch","_ref16","param","InvalidAbiEncodingTypeError","_ref17","InvalidAbiDecodingTypeError","_ref18","InvalidArrayError","InvalidDefinitionTypeError","InvalidAddressError","address","encodeAbiParameters","values","preparedParams","i","push","prepareParam","prepareParams","encodeParams","arrayComponents","getArrayComponents","_ref3","dynamic","Array","isArray","dynamicChild","preparedParam","numberToHex","encoded","map","encodeArray","components","param_","encodeTuple","isAddress","padHex","toLowerCase","encodeAddress","boolToHex","encodeBool","startsWith","_integerRegex$exec","signed","integerRegex","exec","max","BigInt","min","IntegerOutOfRangeError","toString","encodeNumber","Number","paramSize","split","bytesSize","value_","dir","Math","ceil","parseInt","encodeBytes","hexValue","stringToHex","partsLength","parts","slice","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","matches","match","encodeFunctionData","parameters","args","abi","_parameters$functionN","item","getAbiItem","toFunctionSelector","prepareEncodeFunctionData","inputs","concatHex","formatAbiParam","isSelector","isHex","strict","abiItems","filter","toEventSelector","matchedAbiItem","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","argType","abiParameterType","component","test","Uint8Array","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","includes","checksumAddressCache","LruMap","checksumAddress","address_","chainId","has","get","hexAddress","substring","hash","keccak256","stringToBytes","toUpperCase","result","set","getAddress","addressRegex","isAddressCache","options","cacheKey","arr","offset","concatBytes","reduce","acc","start","end","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","SliceOffsetOutOfBoundsError","position","encoder","TextEncoder","toBytes","opts","hex","hexToBytes","numberToBytes","bytes","assertSize","pad","boolToBytes","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","hex_","hexString","j","nibbleLeft","charCodeAt","nibbleRight","encode","to_","to","keccak_256","toHex","toSignatureHash","fn","tupleRegex","formatAbiParameter","_result$array","execTyped","array","indexed","formatAbiParameters","abiParameters","toSignature","def","active","current","level","valid","normalizeSignature","_abiItem$outputs","stateMutability","outputs","sig","bytesRegex","presignMessagePrefix","hashMessage","message","message_","raw","bytesToHex","prefix","toPrefixedMessage","InvalidDomainError","domain","stringify","InvalidPrimaryTypeError","primaryType","JSON","keys","InvalidStructTypeError","getTypesForEIP712Domain","version","verifyingContract","salt","Boolean","validateReference","hashTypedData","EIP712Domain","validateData","struct","integerMatch","_type","base","size_","bytesMatch","validateTypedData","hashStruct","hashDomain","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","unsortedDeps","findTypeDependencies","delete","deps","from","sort","t","encodeType","primaryType_","results","Set","add","prepend","lastIndexOf","parsedType","typeValuePairs","v","regex","string","groups","isTupleRegex"],"sourceRoot":""}